
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
import numpy as np
from bitarray import bitarray
class yc_hop_pyangbind_example__input_LocatorRecord_rloc_explicit_locator_path_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module pyangbind-example - based on the path /input/LocatorRecord/rloc/explicit-locator-path/hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of locator hops forming the explicit path.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__hop_id','__address','__lrs_bits',)

  _yang_name = 'hop'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__hop_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="hop-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True)
    self.__lrs_bits = YANGDynClass(base=unicode, is_leaf=True, yang_name="lrs-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    self.__address = YANGDynClass(base=[unicode,unicode,unicode,unicode,unicode,], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)

    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        setmethod(getattr(args[0], e))

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'input', u'LocatorRecord', u'rloc', u'explicit-locator-path', u'hop']

  def _get_hop_id(self):
    """
    Getter method for hop_id, mapped from YANG variable /input/LocatorRecord/rloc/explicit_locator_path/hop/hop_id (string)

    YANG Description: Unique identifier for the hop.
    """
    return self.__hop_id
      
  def _set_hop_id(self, v, load=False):
    """
    Setter method for hop_id, mapped from YANG variable /input/LocatorRecord/rloc/explicit_locator_path/hop/hop_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hop_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hop_id() directly.

    YANG Description: Unique identifier for the hop.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="hop-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True)
    except (TypeError, ValueError):
      raise ValueError("""hop_id must be of a type compatible with base=unicode, is_leaf=True, yang_name="hop-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True""")
    self.__hop_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hop_id(self):
    self.__hop_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="hop-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /input/LocatorRecord/rloc/explicit_locator_path/hop/address (simple-address)

    YANG Description: AFI address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /input/LocatorRecord/rloc/explicit_locator_path/hop/address (simple-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: AFI address.
    """
    try:
      t = YANGDynClass(v,base=[unicode,unicode,unicode,unicode,unicode,], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""address must be of a type compatible with base=[unicode,unicode,unicode,unicode,unicode,], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=[unicode,unicode,unicode,unicode,unicode,], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)


  def _get_lrs_bits(self):
    """
    Getter method for lrs_bits, mapped from YANG variable /input/LocatorRecord/rloc/explicit_locator_path/hop/lrs_bits (string)

    YANG Description: Flag bits per hop.
    """
    return self.__lrs_bits
      
  def _set_lrs_bits(self, v, load=False):
    """
    Setter method for lrs_bits, mapped from YANG variable /input/LocatorRecord/rloc/explicit_locator_path/hop/lrs_bits (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lrs_bits is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lrs_bits() directly.

    YANG Description: Flag bits per hop.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="lrs-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""lrs_bits must be of a type compatible with base=unicode, is_leaf=True, yang_name="lrs-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__lrs_bits = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lrs_bits(self):
    self.__lrs_bits = YANGDynClass(base=unicode, is_leaf=True, yang_name="lrs-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)

  hop_id = property(_get_hop_id, _set_hop_id)
  address = property(_get_address, _set_address)
  lrs_bits = property(_get_lrs_bits, _set_lrs_bits)


  _pyangbind_elements = {'hop_id': hop_id, 'address': address, 'lrs_bits': lrs_bits, }


class yc_explicit_locator_path_pyangbind_example__input_LocatorRecord_rloc_explicit_locator_path(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module pyangbind-example - based on the path /input/LocatorRecord/rloc/explicit-locator-path. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Explicit Locator Path LCAF type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__hop',)

  _yang_name = 'explicit-locator-path'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__hop = YANGDynClass(base=YANGListType("hop_id",yc_hop_pyangbind_example__input_LocatorRecord_rloc_explicit_locator_path_hop, yang_name="hop", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper), is_container='list', yang_name="hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)

    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        setmethod(getattr(args[0], e))

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'input', u'LocatorRecord', u'rloc', u'explicit-locator-path']

  def _get_hop(self):
    """
    Getter method for hop, mapped from YANG variable /input/LocatorRecord/rloc/explicit_locator_path/hop (list)

    YANG Description: List of locator hops forming the explicit path.
    """
    return self.__hop
      
  def _set_hop(self, v, load=False):
    """
    Setter method for hop, mapped from YANG variable /input/LocatorRecord/rloc/explicit_locator_path/hop (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hop() directly.

    YANG Description: List of locator hops forming the explicit path.
    """
    try:
      t = YANGDynClass(v,base=YANGListType("hop_id",yc_hop_pyangbind_example__input_LocatorRecord_rloc_explicit_locator_path_hop, yang_name="hop", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper), is_container='list', yang_name="hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""hop must be of a type compatible with base=YANGListType("hop_id",yc_hop_pyangbind_example__input_LocatorRecord_rloc_explicit_locator_path_hop, yang_name="hop", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper), is_container='list', yang_name="hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hop(self):
    self.__hop = YANGDynClass(base=YANGListType("hop_id",yc_hop_pyangbind_example__input_LocatorRecord_rloc_explicit_locator_path_hop, yang_name="hop", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper), is_container='list', yang_name="hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)

  hop = property(_get_hop, _set_hop)


  _pyangbind_elements = {'hop': hop, }


class yc_rloc_pyangbind_example__input_LocatorRecord_rloc(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module pyangbind-example - based on the path /input/LocatorRecord/rloc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__address_type','__explicit_locator_path',)

  _yang_name = 'rloc'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address_type = YANGDynClass(base=unicode, is_leaf=True, yang_name="address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    self.__explicit_locator_path = YANGDynClass(base=yc_explicit_locator_path_pyangbind_example__input_LocatorRecord_rloc_explicit_locator_path, is_container='container', yang_name="explicit-locator-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)

    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        setmethod(getattr(args[0], e))

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'input', u'LocatorRecord', u'rloc']

  def _get_address_type(self):
    """
    Getter method for address_type, mapped from YANG variable /input/LocatorRecord/rloc/address_type (string)

    YANG Description: Type of the LISP address.
    """
    return self.__address_type
      
  def _set_address_type(self, v, load=False):
    """
    Setter method for address_type, mapped from YANG variable /input/LocatorRecord/rloc/address_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_type() directly.

    YANG Description: Type of the LISP address.
    """
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""address_type must be of a type compatible with base=unicode, is_leaf=True, yang_name="address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__address_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_type(self):
    self.__address_type = YANGDynClass(base=unicode, is_leaf=True, yang_name="address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)


  def _get_explicit_locator_path(self):
    """
    Getter method for explicit_locator_path, mapped from YANG variable /input/LocatorRecord/rloc/explicit_locator_path (container)

    YANG Description: Explicit Locator Path LCAF type.
    """
    return self.__explicit_locator_path
      
  def _set_explicit_locator_path(self, v, load=False):
    """
    Setter method for explicit_locator_path, mapped from YANG variable /input/LocatorRecord/rloc/explicit_locator_path (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_explicit_locator_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_explicit_locator_path() directly.

    YANG Description: Explicit Locator Path LCAF type.
    """
    try:
      t = YANGDynClass(v,base=yc_explicit_locator_path_pyangbind_example__input_LocatorRecord_rloc_explicit_locator_path, is_container='container', yang_name="explicit-locator-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""explicit_locator_path must be of a type compatible with base=yc_explicit_locator_path_pyangbind_example__input_LocatorRecord_rloc_explicit_locator_path, is_container='container', yang_name="explicit-locator-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__explicit_locator_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_explicit_locator_path(self):
    self.__explicit_locator_path = YANGDynClass(base=yc_explicit_locator_path_pyangbind_example__input_LocatorRecord_rloc_explicit_locator_path, is_container='container', yang_name="explicit-locator-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)

  address_type = property(_get_address_type, _set_address_type)
  explicit_locator_path = property(_get_explicit_locator_path, _set_explicit_locator_path)


  _pyangbind_elements = {'address_type': address_type, 'explicit_locator_path': explicit_locator_path, }


class yc_LocatorRecord_pyangbind_example__input_LocatorRecord(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module pyangbind-example - based on the path /input/LocatorRecord. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__locator_id','__priority','__weight','__multicastPriority','__multicastWeight','__localLocator','__rlocProbed','__routed','__rloc',)

  _yang_name = 'LocatorRecord'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rlocProbed = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rlocProbed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    self.__weight = YANGDynClass(base=np.uint8, is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    self.__multicastPriority = YANGDynClass(base=np.uint8, is_leaf=True, yang_name="multicastPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    self.__localLocator = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="localLocator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    self.__routed = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="routed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    self.__priority = YANGDynClass(base=np.uint8, is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    self.__locator_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="locator-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True)
    self.__rloc = YANGDynClass(base=yc_rloc_pyangbind_example__input_LocatorRecord_rloc, is_container='container', yang_name="rloc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    self.__multicastWeight = YANGDynClass(base=np.uint8, is_leaf=True, yang_name="multicastWeight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)

    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        setmethod(getattr(args[0], e))

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'input', u'LocatorRecord']

  def _get_locator_id(self):
    """
    Getter method for locator_id, mapped from YANG variable /input/LocatorRecord/locator_id (string)
    """
    return self.__locator_id
      
  def _set_locator_id(self, v, load=False):
    """
    Setter method for locator_id, mapped from YANG variable /input/LocatorRecord/locator_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locator_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locator_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="locator-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True)
    except (TypeError, ValueError):
      raise ValueError("""locator_id must be of a type compatible with base=unicode, is_leaf=True, yang_name="locator-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True""")
    self.__locator_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locator_id(self):
    self.__locator_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="locator-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /input/LocatorRecord/priority (uint8)
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /input/LocatorRecord/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.
    """
    try:
      t = YANGDynClass(v,base=np.uint8, is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""priority must be of a type compatible with base=np.uint8, is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=np.uint8, is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)


  def _get_weight(self):
    """
    Getter method for weight, mapped from YANG variable /input/LocatorRecord/weight (uint8)
    """
    return self.__weight
      
  def _set_weight(self, v, load=False):
    """
    Setter method for weight, mapped from YANG variable /input/LocatorRecord/weight (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_weight is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_weight() directly.
    """
    try:
      t = YANGDynClass(v,base=np.uint8, is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""weight must be of a type compatible with base=np.uint8, is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__weight = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_weight(self):
    self.__weight = YANGDynClass(base=np.uint8, is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)


  def _get_multicastPriority(self):
    """
    Getter method for multicastPriority, mapped from YANG variable /input/LocatorRecord/multicastPriority (uint8)
    """
    return self.__multicastPriority
      
  def _set_multicastPriority(self, v, load=False):
    """
    Setter method for multicastPriority, mapped from YANG variable /input/LocatorRecord/multicastPriority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multicastPriority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multicastPriority() directly.
    """
    try:
      t = YANGDynClass(v,base=np.uint8, is_leaf=True, yang_name="multicastPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""multicastPriority must be of a type compatible with base=np.uint8, is_leaf=True, yang_name="multicastPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__multicastPriority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multicastPriority(self):
    self.__multicastPriority = YANGDynClass(base=np.uint8, is_leaf=True, yang_name="multicastPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)


  def _get_multicastWeight(self):
    """
    Getter method for multicastWeight, mapped from YANG variable /input/LocatorRecord/multicastWeight (uint8)
    """
    return self.__multicastWeight
      
  def _set_multicastWeight(self, v, load=False):
    """
    Setter method for multicastWeight, mapped from YANG variable /input/LocatorRecord/multicastWeight (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multicastWeight is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multicastWeight() directly.
    """
    try:
      t = YANGDynClass(v,base=np.uint8, is_leaf=True, yang_name="multicastWeight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""multicastWeight must be of a type compatible with base=np.uint8, is_leaf=True, yang_name="multicastWeight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__multicastWeight = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multicastWeight(self):
    self.__multicastWeight = YANGDynClass(base=np.uint8, is_leaf=True, yang_name="multicastWeight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)


  def _get_localLocator(self):
    """
    Getter method for localLocator, mapped from YANG variable /input/LocatorRecord/localLocator (boolean)
    """
    return self.__localLocator
      
  def _set_localLocator(self, v, load=False):
    """
    Setter method for localLocator, mapped from YANG variable /input/LocatorRecord/localLocator (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localLocator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localLocator() directly.
    """
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="localLocator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""localLocator must be of a type compatible with base=YANGBool, is_leaf=True, yang_name="localLocator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__localLocator = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localLocator(self):
    self.__localLocator = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="localLocator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)


  def _get_rlocProbed(self):
    """
    Getter method for rlocProbed, mapped from YANG variable /input/LocatorRecord/rlocProbed (boolean)
    """
    return self.__rlocProbed
      
  def _set_rlocProbed(self, v, load=False):
    """
    Setter method for rlocProbed, mapped from YANG variable /input/LocatorRecord/rlocProbed (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rlocProbed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rlocProbed() directly.
    """
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="rlocProbed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""rlocProbed must be of a type compatible with base=YANGBool, is_leaf=True, yang_name="rlocProbed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__rlocProbed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rlocProbed(self):
    self.__rlocProbed = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rlocProbed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)


  def _get_routed(self):
    """
    Getter method for routed, mapped from YANG variable /input/LocatorRecord/routed (boolean)
    """
    return self.__routed
      
  def _set_routed(self, v, load=False):
    """
    Setter method for routed, mapped from YANG variable /input/LocatorRecord/routed (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routed() directly.
    """
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="routed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""routed must be of a type compatible with base=YANGBool, is_leaf=True, yang_name="routed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__routed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routed(self):
    self.__routed = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="routed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)


  def _get_rloc(self):
    """
    Getter method for rloc, mapped from YANG variable /input/LocatorRecord/rloc (container)
    """
    return self.__rloc
      
  def _set_rloc(self, v, load=False):
    """
    Setter method for rloc, mapped from YANG variable /input/LocatorRecord/rloc (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rloc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rloc() directly.
    """
    try:
      t = YANGDynClass(v,base=yc_rloc_pyangbind_example__input_LocatorRecord_rloc, is_container='container', yang_name="rloc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""rloc must be of a type compatible with base=yc_rloc_pyangbind_example__input_LocatorRecord_rloc, is_container='container', yang_name="rloc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__rloc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rloc(self):
    self.__rloc = YANGDynClass(base=yc_rloc_pyangbind_example__input_LocatorRecord_rloc, is_container='container', yang_name="rloc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)

  locator_id = property(_get_locator_id, _set_locator_id)
  priority = property(_get_priority, _set_priority)
  weight = property(_get_weight, _set_weight)
  multicastPriority = property(_get_multicastPriority, _set_multicastPriority)
  multicastWeight = property(_get_multicastWeight, _set_multicastWeight)
  localLocator = property(_get_localLocator, _set_localLocator)
  rlocProbed = property(_get_rlocProbed, _set_rlocProbed)
  routed = property(_get_routed, _set_routed)
  rloc = property(_get_rloc, _set_rloc)


  _pyangbind_elements = {'locator_id': locator_id, 'priority': priority, 'weight': weight, 'multicastPriority': multicastPriority, 'multicastWeight': multicastWeight, 'localLocator': localLocator, 'rlocProbed': rlocProbed, 'routed': routed, 'rloc': rloc, }


class yc_mapping_record_pyangbind_example__input_mapping_record(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module pyangbind-example - based on the path /input/mapping-record. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__recordTtl','__maskLength','__mapVersion','__action','__authoritative',)

  _yang_name = 'mapping-record'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__recordTtl = YANGDynClass(base=np.int32, is_leaf=True, yang_name="recordTtl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    self.__action = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'Drop': {}, u'NativelyForward': {}, u'SendMapRequest': {}, u'NoAction': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    self.__authoritative = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="authoritative", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    self.__mapVersion = YANGDynClass(base=np.int16, is_leaf=True, yang_name="mapVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    self.__maskLength = YANGDynClass(base=np.uint8, is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)

    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        setmethod(getattr(args[0], e))

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'input', u'mapping-record']

  def _get_recordTtl(self):
    """
    Getter method for recordTtl, mapped from YANG variable /input/mapping_record/recordTtl (int32)
    """
    return self.__recordTtl
      
  def _set_recordTtl(self, v, load=False):
    """
    Setter method for recordTtl, mapped from YANG variable /input/mapping_record/recordTtl (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_recordTtl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_recordTtl() directly.
    """
    try:
      t = YANGDynClass(v,base=np.int32, is_leaf=True, yang_name="recordTtl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""recordTtl must be of a type compatible with base=np.int32, is_leaf=True, yang_name="recordTtl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__recordTtl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_recordTtl(self):
    self.__recordTtl = YANGDynClass(base=np.int32, is_leaf=True, yang_name="recordTtl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)


  def _get_maskLength(self):
    """
    Getter method for maskLength, mapped from YANG variable /input/mapping_record/maskLength (uint8)
    """
    return self.__maskLength
      
  def _set_maskLength(self, v, load=False):
    """
    Setter method for maskLength, mapped from YANG variable /input/mapping_record/maskLength (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maskLength is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maskLength() directly.
    """
    try:
      t = YANGDynClass(v,base=np.uint8, is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""maskLength must be of a type compatible with base=np.uint8, is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__maskLength = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maskLength(self):
    self.__maskLength = YANGDynClass(base=np.uint8, is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)


  def _get_mapVersion(self):
    """
    Getter method for mapVersion, mapped from YANG variable /input/mapping_record/mapVersion (int16)
    """
    return self.__mapVersion
      
  def _set_mapVersion(self, v, load=False):
    """
    Setter method for mapVersion, mapped from YANG variable /input/mapping_record/mapVersion (int16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mapVersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mapVersion() directly.
    """
    try:
      t = YANGDynClass(v,base=np.int16, is_leaf=True, yang_name="mapVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""mapVersion must be of a type compatible with base=np.int16, is_leaf=True, yang_name="mapVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__mapVersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mapVersion(self):
    self.__mapVersion = YANGDynClass(base=np.int16, is_leaf=True, yang_name="mapVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)


  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /input/mapping_record/action (enumeration)
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /input/mapping_record/action (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.
    """
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'Drop': {}, u'NativelyForward': {}, u'SendMapRequest': {}, u'NoAction': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""action must be of a type compatible with base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'Drop': {}, u'NativelyForward': {}, u'SendMapRequest': {}, u'NoAction': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'Drop': {}, u'NativelyForward': {}, u'SendMapRequest': {}, u'NoAction': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)


  def _get_authoritative(self):
    """
    Getter method for authoritative, mapped from YANG variable /input/mapping_record/authoritative (boolean)
    """
    return self.__authoritative
      
  def _set_authoritative(self, v, load=False):
    """
    Setter method for authoritative, mapped from YANG variable /input/mapping_record/authoritative (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authoritative is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authoritative() directly.
    """
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="authoritative", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""authoritative must be of a type compatible with base=YANGBool, is_leaf=True, yang_name="authoritative", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__authoritative = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authoritative(self):
    self.__authoritative = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="authoritative", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)

  recordTtl = property(_get_recordTtl, _set_recordTtl)
  maskLength = property(_get_maskLength, _set_maskLength)
  mapVersion = property(_get_mapVersion, _set_mapVersion)
  action = property(_get_action, _set_action)
  authoritative = property(_get_authoritative, _set_authoritative)


  _pyangbind_elements = {'recordTtl': recordTtl, 'maskLength': maskLength, 'mapVersion': mapVersion, 'action': action, 'authoritative': authoritative, }


class yc_input_pyangbind_example__input(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module pyangbind-example - based on the path /input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__LocatorRecord','__mapping_record',)

  _yang_name = 'input'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__LocatorRecord = YANGDynClass(base=YANGListType("locator_id",yc_LocatorRecord_pyangbind_example__input_LocatorRecord, yang_name="LocatorRecord", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper), is_container='list', yang_name="LocatorRecord", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    self.__mapping_record = YANGDynClass(base=yc_mapping_record_pyangbind_example__input_mapping_record, is_container='container', yang_name="mapping-record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)

    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        setmethod(getattr(args[0], e))

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'input']

  def _get_LocatorRecord(self):
    """
    Getter method for LocatorRecord, mapped from YANG variable /input/LocatorRecord (list)
    """
    return self.__LocatorRecord
      
  def _set_LocatorRecord(self, v, load=False):
    """
    Setter method for LocatorRecord, mapped from YANG variable /input/LocatorRecord (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_LocatorRecord is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_LocatorRecord() directly.
    """
    try:
      t = YANGDynClass(v,base=YANGListType("locator_id",yc_LocatorRecord_pyangbind_example__input_LocatorRecord, yang_name="LocatorRecord", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper), is_container='list', yang_name="LocatorRecord", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""LocatorRecord must be of a type compatible with base=YANGListType("locator_id",yc_LocatorRecord_pyangbind_example__input_LocatorRecord, yang_name="LocatorRecord", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper), is_container='list', yang_name="LocatorRecord", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__LocatorRecord = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_LocatorRecord(self):
    self.__LocatorRecord = YANGDynClass(base=YANGListType("locator_id",yc_LocatorRecord_pyangbind_example__input_LocatorRecord, yang_name="LocatorRecord", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper), is_container='list', yang_name="LocatorRecord", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)


  def _get_mapping_record(self):
    """
    Getter method for mapping_record, mapped from YANG variable /input/mapping_record (container)
    """
    return self.__mapping_record
      
  def _set_mapping_record(self, v, load=False):
    """
    Setter method for mapping_record, mapped from YANG variable /input/mapping_record (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mapping_record is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mapping_record() directly.
    """
    try:
      t = YANGDynClass(v,base=yc_mapping_record_pyangbind_example__input_mapping_record, is_container='container', yang_name="mapping-record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""mapping_record must be of a type compatible with base=yc_mapping_record_pyangbind_example__input_mapping_record, is_container='container', yang_name="mapping-record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__mapping_record = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mapping_record(self):
    self.__mapping_record = YANGDynClass(base=yc_mapping_record_pyangbind_example__input_mapping_record, is_container='container', yang_name="mapping-record", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)

  LocatorRecord = property(_get_LocatorRecord, _set_LocatorRecord)
  mapping_record = property(_get_mapping_record, _set_mapping_record)


  _pyangbind_elements = {'LocatorRecord': LocatorRecord, 'mapping_record': mapping_record, }


class pyangbind_example(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module pyangbind-example - based on the path /pyangbind-example. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This YANG module defines the LISP Canonical Address Formats
(LCAF) for LISP. The module can be extended by vendors to
define vendor-specific parameters.

Copyright (c) 2014 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 6338; see
the RFC itself for full legal notices.


  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__input',)

  _yang_name = 'pyangbind-example'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__input = YANGDynClass(base=yc_input_pyangbind_example__input, is_container='container', yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)

    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        setmethod = getattr(self, "_set_%s" % e)
        setmethod(getattr(args[0], e))

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /input (container)
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /input (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.
    """
    try:
      t = YANGDynClass(v,base=yc_input_pyangbind_example__input, is_container='container', yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)
    except (TypeError, ValueError):
      raise ValueError("""input must be of a type compatible with base=yc_input_pyangbind_example__input, is_container='container', yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True""")
    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=yc_input_pyangbind_example__input, is_container='container', yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True)

  input = property(_get_input, _set_input)


  _pyangbind_elements = {'input': input, }


